name: Keep Streamlit Apps Alive

on:
  schedule:
    - cron: "*/5 * * * *"   # ejecuta cada 5 minutos
  workflow_dispatch:        # permite lanzarlo manualmente

jobs:
  keepalive:
    runs-on: ubuntu-latest

    # Usa la imagen oficial de Playwright con los navegadores ya instalados
    container:
      image: mcr.microsoft.com/playwright/python:v1.45.0-jammy

    steps:
      # Instala el paquete de Python (los browsers ya vienen en la imagen)
      - name: Install Playwright (Python)
        run: |
          python -m pip install --upgrade pip
          python -m pip install --no-cache-dir playwright==1.45.0

      # Visita tus apps: si está dormida, la despierta; espera a que cargue y la mantiene abierta un rato
      - name: Visit Streamlit apps (wake, wait until ready, keep open)
        env:
          APP_URLS: |
            https://optibat-metrics-dashboard-flags.streamlit.app/
            https://optimitive-eda-analyzer.streamlit.app/
        run: |
          python - <<'PY'
          import os, re, time
          from playwright.sync_api import sync_playwright

          urls = [u.strip() for u in os.environ["APP_URLS"].splitlines() if u.strip()]

          def is_awake(page):
              try:
                  return page.locator("[data-testid='stAppViewContainer']").count() > 0
              except:
                  return False

          def try_wake(page):
              # 1) patrones por rol/nombre (varias variantes/idiomas)
              patterns = [
                  r"get this app back up",
                  r"wake.*back up",
                  r"wake.*up",
                  r"volver.*activar",
                  r"despert",
                  r"reanudar|reabrir",
              ]
              for pat in patterns:
                  loc = page.get_by_role("button", name=re.compile(pat, re.I))
                  if loc.count() > 0 and loc.first.is_visible():
                      loc.first.click()
                      return True
              # 2) selectores genéricos por texto
              for sel in [
                  "button:has-text('get this app back up')",
                  "text=/get this app back up/i",
                  "text=/wake.*back up/i",
              ]:
                  loc = page.locator(sel)
                  if loc.count() > 0 and loc.first.is_visible():
                      loc.first.click()
                      return True
              # 3) último recurso: si no está despierta y hay un único botón visible, clicarlo
              if not is_awake(page):
                  btns = page.locator("button:visible")
                  if btns.count() == 1:
                      btns.first.click()
                      return True
              return False

          def wait_until_ready(page, total_ms=300000):
              # espera hasta 5 min a que aparezca la app real
              deadline = time.time() + total_ms/1000
              while time.time() < deadline:
                  if is_awake(page):
                      return True
                  page.wait_for_timeout(2000)
                  # a veces hay 404/Not found transitorio; recarga
                  try:
                      page.reload(wait_until="domcontentloaded", timeout=60000)
                  except Exception:
                      pass
              return False

          with sync_playwright() as p:
              browser = p.chromium.launch(headless=True)
              for url in urls:
                  ctx = browser.new_context()
                  page = ctx.new_page()
                  try:
                      print(f"Visitando: {url}")
                      page.goto(url, wait_until="domcontentloaded", timeout=180000)
                      page.wait_for_timeout(1500)

                      awake_before = is_awake(page)
                      woke = False
                      if not awake_before:
                          for _ in range(3):
                              if try_wake(page):
                                  woke = True
                                  break
                              page.wait_for_timeout(1500)

                      ready = wait_until_ready(page, total_ms=300000)

                      # Mantener la sesión abierta un rato para dejarla "caliente"
                      if ready:
                          page.wait_for_timeout(90000)  # 90 s

                      print(f"✔ OK: awake_before={awake_before}, woke={woke}, ready={ready}, title='{page.title()}'")
                  except Exception as e:
                      print(f"ERROR visitando {url}: {e}")
                  finally:
                      ctx.close()
              browser.close()
          PY
